{
  parserClass="se.clau.ironclad.language.ErlangParser"
  parserUtilClass="se.clau.ironclad.language.ErlangParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  tokens = [
    PLUS            = "+"
    MINUS           = "-"
    MULTIPLY        = "*"
    FLOAT_DIV       = "/"
    EQEQ            = "=="
    NEQ             = "/="
    STRONG_EQ       = "=:="
    STRONG_NEQ      = "=/="
    GT              = ">"
    GTEQ            = ">="
    LT              = "<"
    LTEQ            = "=<"
    PLUS_PLUS       = "++"
    MINUS_MINUS     = "--"
    EQ              = "="
    BANG            = "!"
    MAYBE_EQ        = "?="

    L_DOUBLE_ANGLE  = "<<"
    R_DOUBLE_ANGLE  = ">>"

    L_PAREN         = "("
    R_PAREN         = ")"
    L_CURLY         = "{"
    R_CURLY         = "}"
    L_SQUARE        = "["
    R_SQUARE        = "]"
    COLON           = ":"
    COLON_COLON     = "::"
    DOUBLE_BAR      = "||"
    VERTICAL_BAR    = "|"
    SEMICOLON       = ";"
    COMMA           = ","
    PERIOD          = "."
    HASH_SYMBOL     = "#"
    QUESTION        = "?"
    MATCH           = ":="
    SINGLE_QUOTE    = "'"

    R_DOUBLE_ARROW  = "=>"
    L_DOUBLE_ARROW  = "<="
    L_ARROW         = "<-"
    R_ARROW         = "->"

    INTEGER_DIV     = "div"
    REMAINDER       = "rem"
    OR              = "or"
    XOR             = "xor"
    AND             = "and"
    NOT             = "not"
    BINARY_OR       = "bor"
    BINARY_XOR      = "bxor"
    BINARY_AND      = "band"
    BINARY_NOT      = "bnot"
    BINARY_SHIFT_L  = "bsl"
    BINARY_SHIFT_R  = "bsr"
    ANDALSO         = "andalso"
    ORELSE          = "orelse"

    // These tokens must never appear in final PSI, and are eliminated by ErlangFlexAdapter while lexing
    PP_DEFINE       = "preprocessor -define"
    PP_UNDEF        = "preprocessor -undef"
    PP_IFDEF        = "preprocessor -ifdef"
    PP_IF           = "preprocessor -if"
    PP_ELIF         = "preprocessor -elif"
    PP_IFNDEF       = "preprocessor -ifndef"
    PP_ELSE         = "preprocessor -else"
    PP_ENDIF        = "preprocessor -endif"
    PP_INCLUDE      = "preprocessor -include"
    PP_INCLUDELIB   = "preprocessor -include_lib"
  ]

  psiClassPrefix="ErlPsi"
  psiImplClassSuffix="Impl"
  psiPackage="se.clau.ironclad.language.psi"
  psiImplPackage="se.clau.ironclad.language.psi.impl"

  elementTypeHolderClass="se.clau.ironclad.language.ErlangElementTypes"
  //elementTypePrefix="TOK_"
  elementTypeClass="se.clau.ironclad.language.ErlangElementType"
  tokenTypeClass="se.clau.ironclad.language.ErlangTokenType"
}

erlangFile ::= erlangRoot | escriptRoot | termsRoot

private termsRoot ::= &<<isTermsSyntaxFile>> literalExprWithPeriod *
private erlangRoot ::= &<<isErlangSyntaxFile>> form *
private escriptRoot ::= &<<isEscriptSyntaxFile>>

// An Erlang module form is an attribute, or a function definition
//private formWithPeriod ::= form PERIOD {recoverWhile=formRecover pin=1}
//private formRecover ::= !(PLUS | MINUS | L_DOUBLE_ANGLE | QUESTION
//    | L_SQUARE | L_CURLY | atom | BINARY_NOT | CHAR_LITERAL
//    | float | INTEGER_LITERAL | NOT | STRING_LITERAL | VAR | HASH_SYMBOL | PERIOD)
private form ::= functionDef
    | preprocessorDefine
    | moduleAttr
    | !<<eofOrSpace>>

private literalExprWithPeriod ::= literalExpr PERIOD {pin=1}

//
// General Erlang syntax constructs, shared with different file types
//
literalExpr ::= INTEGER_LITERAL | float | char | STRING_LITERAL | CHAR_LITERAL | atom

// Expr same as literal expr but allows function calls and variables
expr ::= VAR | literalExpr
atom ::= ATOM_NAME | (SINGLE_QUOTE ATOM_NAME SINGLE_QUOTE) {pin(".*") = 1}

//
// Erlang Module constructs
//
moduleAttr ::= MINUS atom ( L_PAREN moduleAttrContents R_PAREN )? PERIOD {pin=2}
private moduleAttrContents ::= literalExpr? ( COMMA literalExpr )*

functionDef ::= atom L_PAREN functionDefArgs R_PAREN R_ARROW functionDefBody PERIOD
private functionDefArgs ::= functionDefArg ( COMMA functionDefArg )*
functionDefArg ::= VAR | atom // TODO: Proper match expression syntax
private functionDefBody ::= expr ( COMMA expr )*

//
// Preprocessor
//
private preprocessorDirectiveEnd ::= R_PAREN PERIOD
private preprocessorDirectiveRecover ::= !preprocessorDirectiveEnd
private preprocessorMacroIdent ::= VAR | ATOM_NAME // lowercase or uppercase, all good
preprocessorDefine ::= PP_DEFINE L_PAREN preprocessorMacroIdent
    preprocessorDefineArgs? COMMA
    preprocessorMacroBodyToken*
    preprocessorDirectiveEnd {pin=2}
preprocessorDefineArgs ::= L_PAREN VAR ( COMMA VAR )* R_PAREN
private preprocessorMacroBodyToken ::= <<macroBodyAnyToken>> {pin=1 recoverWhile=preprocessorDirectiveRecover}
